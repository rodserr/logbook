{
  "hash": "dff7bcfd0710714b8ac5370d5614188b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Visualize Running Routes\"\ndescription: |\n  Extracting data from Strava API to build route Visualizations\ndate: 2024-08-08\ncategories: [viz]\n---\n\n\nThis is a tutorial-like post to practice data manipulation, visualization and API principles. There has been one year since I started running in a weekly basis, and recently I completed my longest run so far (25km). I log my runs in Strava which has an API with free features that let you get some stats and even route points. Lets build a visualization of this run.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::opts_chunk$set(\n  eval = TRUE,\n  message = FALSE,\n  warning = FALSE,\n  dev = \"ragg_png\",\n  dpi = 300\n)\n\n.post_path <- 'posts/strava-route-visualization'\nhere::i_am(glue::glue('{.post_path}/index.qmd'))\nrenv::use(lockfile = here::here(.post_path, \"renv.lock\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr) # Data manipulation\nlibrary(httr2) # Make HTTP requests\nlibrary(jsonlite) # Handle json files\nlibrary(ggmap) # Mapping geometries\nlibrary(purrr) # Manipulate list elegantly\nlibrary(ggplot2) # Visualizations\nlibrary(here) # Working directory helper\nlibrary(systemfonts) # Work with fonts\nlibrary(ragg) # Work with fonts\n```\n:::\n\n\n## GET Strava Activity Data\n\nTo extract data from strava, you need to create and register an app to get credentials. Follow steps in [Getting Started](https://developers.strava.com/docs/getting-started/).\n\nStrava API use OAuth authentication protocol. Hadley has an article that explain how to connect OAuth from R using [httr2](https://httr2.r-lib.org/articles/oauth.html#authorization-code-flow)\n\nBasically it consist in getting credentials (client ID and secrets) and create the client to perform the authentication flow.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set client\nclient <- httr2::oauth_client(\n  id = Sys.getenv('STRAVA_CLIENT_ID'),\n  secret = Sys.getenv('STRAVA_CLIENT_SECRET'),\n  token_url = \"https://www.strava.com/oauth/token\",\n  name = \"strava-oauth-test\"\n)\n\n# Apply client flow\noauth <- httr2::oauth_flow_auth_code(\n  client = client,\n  auth_url = 'https://www.strava.com/oauth/authorize',\n  scope = 'activity:read'\n)\n\n# Save temporal access token in environtment\nSys.setenv(\"STRAVA_ACCESS_TOKEN\" = oauth$access_token)\n```\n:::\n\n\nActivity ID is explicit in the url of the strava webpage for the required activtity. We hit the `/activity` endpoint setting the activity target id\n\n::: {.cell}\n\n```{.r .cell-code}\nactivity <- request(\"https://www.strava.com/api/v3/activities/11886025399\") %>% \n  httr2::req_auth_bearer_token(\n    Sys.getenv(\"STRAVA_ACCESS_TOKEN\")\n  ) %>%\n  httr2::req_url_query(include_all_efforts = T) %>% # Include Splits and efforts\n  req_perform() %>% \n  resp_body_json()\n```\n:::\n\n\n\n\n\n\n## Bulding dataframes for the visualization\n\nWe got metrics for the activity like total distance, moving time and elevation. Lets store them to use in the visual\n\n::: {.cell}\n\n```{.r .cell-code}\nmetrics <- activity %>% \n  keep_at(c('distance', 'moving_time', 'total_elevation_gain', 'average_heartrate')) %>% \n  flatten_dfc() %>% \n  mutate(\n    moving_time = moving_time/60,\n    distance = distance/1000,\n    pace = moving_time/distance\n  )\n\nmetrics\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 Ã— 5\n  distance moving_time total_elevation_gain average_heartrate  pace\n     <dbl>       <dbl>                <dbl>             <dbl> <dbl>\n1     25.3        155.                 75.2              147.  6.11\n```\n\n\n:::\n:::\n\n\nWe want to plot the route of the run, so we need to extract the polyline. This comes encoded with google algorithm, we can use `googlePolylines` package to decode it.\n\n::: {.cell}\n\n```{.r .cell-code}\nroute <- activity %>% \n  pluck('map', 'polyline', 1) %>% \n  googlePolylines::decode() %>% \n  pluck(1) %>% \n  mutate(\n    # Compute Distance between points to locate the fastest split in the polyline\n    dist = geosphere::distHaversine(\n      cbind(lon, lat),\n      cbind(lag(lon), lag(lat))\n    ),\n    distcum = cumsum(tidyr::replace_na(dist, 0))\n  )\n```\n:::\n\n\nTo apply a map backgroung we can use ggmap and the free tier of stadia maps. It needs an API key that you could get folling instructions in the [ggmap readme](https://cran.r-project.org/web/packages/ggmap/readme/README.html)\n\n::: {.cell}\n\n```{.r .cell-code}\nbbox <- make_bbox(lon, lat, data = route)\nmap <- get_stadiamap( bbox = bbox, maptype = \"stamen_toner_lite\", zoom = 14 )\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nSo far we have elements to build a visual with the route in a city map background\n\n::: {.cell .column-page}\n\n```{.r .cell-code}\n.linecolor <- '#fc4c02'\n\nmap_route <- ggmap(map) +\n\n  # Path (route)\n  geom_path(\n    data = route,\n    color = .linecolor,\n    linewidth = 2.5,\n    aes(x = lon, y = lat)\n  ) +\n  geom_path(\n    data = route,\n    color = 'white',\n    linewidth = 0.2,\n    aes(x = lon, y = lat)\n  )\n\nmap_route\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/map_simple-1.png){width=3000}\n:::\n:::\n\n\nThere is no clear initial and finish points in the route. That is because I did a circuit. Lets add it to make it more explicit\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart <- route %>%\n  # First record of route is start\n  slice_head(n = 1) %>% \n  mutate(label_ = 'Start')\n\n  # Points to build an arrow to signal start direction\nstart_arrow <- route %>%\n  filter(\n    row_number() %in% c(1, 6)\n  ) %>% \n  select(lat, lon) %>% \n  mutate(\n    lat = lat+0.0012,\n    aux = c('start', 'end')\n  ) %>% \n  tidyr::pivot_wider(names_from = aux, values_from = c(lat, lon))\n```\n:::\n\n\nStrava also logs performance metrics for every kilometer, they call it `splits`. We can investigate the location of the fastest split.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsplits <- activity$splits_metric %>% \n  map(~flatten(.x) %>% as_tibble) %>% \n  list_rbind() %>% \n  mutate(\n    # Get pace in minutes per kilometer\n    pace = (lubridate::today() + lubridate::seconds_to_period(moving_time)) %>% \n      format(format = '%M:%S') %>% \n      stringr::str_remove('^0')\n  )\n\nbest_split <- splits %>% \n  filter(distance == 1000) %>% # Omit final split with less than 1 km of distance\n  slice_min(order_by = moving_time, n = 1, with_ties = FALSE)\n\n# Last point of the fastest kilometer\nbest_split_coord <- route %>% \n  mutate(\n    closest_coord = abs(distcum-(best_split$split*1000))\n  ) %>% \n  slice_min(order_by = closest_coord, n = 1, with_ties = FALSE) %>% \n  mutate(\n    pace = best_split$pace,\n    avg_heartrate = best_split$average_heartrate,\n    label_ = glue::glue('<span style=\"font-size:7pt;\">*end of*</span> **Fastest Kilometer**<br>Pace: {pace}<br>Avg HeartRate: {round(avg_heartrate, 0)} bpm')\n  )\n```\n:::\n\n\n## Final Plot\n\nLets include start point and fastest split in the visual. Also lets enhance fonts, [this](https://www.cararthompson.com/posts/2024-01-12-using-fonts-in-r-for-dataviz/2024-01-12_getting-fonts-to-work) is a good post on how to use custom fonts in ggplot\n\n\n::: {.cell .column-page}\n\n```{.r .cell-code}\n.linecolor <- '#fc4c02'\n\nmap_route +\n  \n  # Start-Finish points\n  geom_point(\n    data = start,\n    size = 4, color = .linecolor,\n    aes(x = lon, y = lat)\n  ) +\n  \n  # Start-Finish Arrow Labels\n  geom_segment(\n    data = start_arrow,\n    color = .linecolor,\n    linewidth = 1,\n    arrow = arrow(length = unit(0.05, \"npc\")),\n    aes(\n      x = lon_start, xend = lon_end,\n      y = lat_start, yend = lat_end\n    )\n  ) +\n  geom_text(\n    data = start,\n    color = .linecolor,\n    size = 4,\n    aes(x = lon, y = lat+0.0022, label = label_)\n  ) +\n  \n  # Best Split\n  geom_segment(\n    data = best_split_coord,\n    color = .linecolor,\n    linewidth = 1,\n    aes(x = lon, y = lat, yend = lat-0.012)\n  ) +\n  ggtext::geom_richtext(\n    data = best_split_coord,\n    nudge_y = -0.012,\n    color = 'white',\n    size = 4,\n    fill = .linecolor,\n    aes(x = lon, y = lat, label = label_)\n  ) +\n  \n  # Theme\n  theme_void(\n    base_family = 'Saira'\n  ) +\n  labs(\n    title = \"25 km @Caracas\",\n    tag = glue::glue(\"**Pace:** {round(metrics$pace, 2)}<br>**Elevation Gain:** {metrics$total_elevation_gain}\"),\n    caption = \"Source: Strava | Graphic: Rodrigo Serrano\"\n  ) +\n  theme(\n    plot.title = element_text(size = 25, hjust = .1, face = 'bold'),\n    plot.caption = element_text(hjust = .95),\n    plot.tag.position = c(0.80, 0.92),\n    plot.tag = ggtext::element_markdown(size = 10, hjust = 0)\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot_map-1.png){width=3000}\n:::\n:::\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}