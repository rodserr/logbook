{
  "hash": "50335bab5ca6ca017cdf207ca335a35a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"EPL Standings - table contest 2021\"\ndescription: |\n  Making a Selectable and Editable DT::DataTable in Shiny.\nauthor:\n  - name: Rodrigo Serrano\n    url: https://rodserr.github.io/logbook\ndate: 2021-10-27\npreview: epl-logo-solid.jpg\ncategories:\n  - Shiny\n---\n\n\n\n\nI will document the making of a selectable and editable DT::dataTable in shiny. This will also be my submission to participate on RStudio table contest for 2021. I will use `understatr` package to `get_league_teams_stats` for the 2021/2022 Premier League and build a standings table. This table will be selectable in order to display cumulative xG for the selected team, and editable to add comments for the team in a Total xG plot. Visit shiny [here](https://rodserr.shinyapps.io/epl-standings/)\n\n### Packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries----\nlibrary(shiny)\nlibrary(understatr)\nlibrary(tidyverse)\nlibrary(DT) \nlibrary(ggrepel) # include automated positioned text in ggplot\nlibrary(ggimage) # include team logo in ggplot\nlibrary(shinycssloaders) # Nice spinner to show while loading outputs\nlibrary(bslib) # to themed the shiny\nlibrary(thematic) # to pass the bslib theme to ggplots\n```\n:::\n\n\n### Getting Data\n\nLet's use `understatr::get_league_teams_stats` to retrieve results for every team in the 2021/2022 Premier League. `team_logo.csv` contains image addresses for the logo of every team\n\n\n::: {.cell}\n\n```{.r .cell-code}\nepl_2021 <- get_league_teams_stats(league_name = \"EPL\", year = 2021)\nteam_logo <- read_csv('table-contest-2021/team_logo.csv')\n```\n:::\n\n\nLet's summarise **epl_2021** and join the URL of the logos, which will be our standing table and also our dataframe to display Total xG plot. We also made the cumulative xG dataframe that will be team filtered every time we select a row in the standings table to display only the curve for the selected team\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Standings\nepl_standings <- epl_2021 %>% \n    group_by(team_name) %>% \n    summarise(\n        Loses = sum(loses),\n        Draws = sum(draws),\n        Wins = sum(wins),\n        Pts = sum(pts),\n        GD = sum(scored)-sum(missed),\n        Comment = '',\n        xG = sum(xG),\n        xGA = sum(xGA),\n        .groups = 'drop'\n    ) %>% \n    arrange(desc(Pts)) %>% \n    left_join(team_logo) %>% \n    mutate(Team = sprintf('<img src=\"%s\" height=\"28\"></img>', logo)) %>% \n    relocate(Team)\n\n# Cumulative xG\nroll_xG <- epl_2021 %>% \n    group_by(team_name) %>%\n    arrange(team_name, date) %>% \n    transmute(\n        match_day = 1:n(),\n        team_name,\n        xG = cumsum(xG),\n        xGA = cumsum(xGA),\n        G = cumsum(scored),\n        GA = cumsum(missed)\n    ) %>% \n    ungroup() %>% \n    pivot_longer(contains('G')) %>% \n    mutate(type = if_else(name %in% c('G', 'GA'), 'real', 'expected'))\n```\n:::\n\n\n### Setting Reactivity and observes\n\nThe first thing we need to do is create a `reactiveValues` and set an `observe` to catch the value every time the source dataframe changes, in this case, it would not change since *epl_standings* is static, but this would be necessary if *epl_standings* were reactive. Also, we need to create a `dataTableProxy` to store the previous value for the main dataTable -'standings' is our `DT::dataTable` that we will create later on-\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create Empty Reactive Value\ntable_reactive_value <- reactiveValues(df = NULL)\n\n# observe in case of epl_standings would be reactive\nobserve({\n  table_reactive_value$df <- epl_standings\n})\n\n# Creating table proxy to store previous values\nstandings_proxy <- dataTableProxy('standings')\n```\n:::\n\n\nNext, we set the `observeEvent` that in the event of a cell edit, will update the value of the `reactiveValue` that stores the copy of the source dataframe. Note the event will always be an input of the nameOfTheDT`_cell_edit` \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Update table\nobserveEvent(input$standings_cell_edit, {\n  info = input$standings_cell_edit\n  str(info)\n  \n  # Location and value of the edit\n  i = info$row\n  j = info$col \n  v = info$value\n  \n  # Coerce value of the same data type and replace proxy\n  table_reactive_value$df[i, j] <- DT::coerceValue(v, pull(table_reactive_value$df[i, j]))\n  aux_table <- table_reactive_value$df\n  replaceData(standings_proxy, aux_table, resetPaging = FALSE, rownames = T)\n})\n```\n:::\n\n\nNow lets build the `DT::dataTable`. The only column that will not be selectable is *Comment* which is column number 8, so we build a matrix of nrow(epl_standings) rows and two columns that maps the cells of epl_standings that will not be selectable. Column one and column two indicates row number and column number respectively. All values are negative, in that way we specify the no selectable parts of the table\n\nThe editable range is easier to set with the disable argument. Note that there are 3 columns that we do not want to display in the table, we do not use `dplyr::select` to remove them, instead, we set `columnDefs` argument otherwise would be a mismatch between the reactiveValue and the dataTable columns\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutput$standings <- DT::renderDataTable({\n  \n  ncolumns <- ncol(epl_standings)\n  nrows <- nrow(epl_standings)\n  unselectable_matrix <- matrix(c(-(1:nrows), rep(-8, nrows)), ncol = 2)\n  \n  epl_standings %>%\n    DT::datatable(\n      rownames = T,\n      style = 'bootstrap',\n      selection = list(mode = 'single', target = \"cell\", selectable = unselectable_matrix),\n      editable = list(target = \"cell\", disable = list(columns = 1:7)),\n      escape = F,\n      options = list(\n        searching = F,\n        paging = F,\n        info = F,\n        columnDefs = list(\n          list(visible=FALSE, targets = c(9,10,11)),\n          list(className = 'dt-center', targets = '_all')\n        )\n      )\n    )\n  \n})\n```\n:::\n\n\nNow we use the reactiveValue to build the output with the dataframe edited, in this case, a ggplot\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutput$total_xG <- renderPlot({\n  \n  table_reactive_value$df %>%\n    ggplot(aes(x = xG, y = xGA, label = Comment)) +\n    geom_image(aes(image = logo), asp = 10/5, size = .04) +\n    geom_text_repel(box.padding = 1, max.overlaps = Inf, size = 4,\n                    min.segment.length = 0, segment.curvature = -.5) +\n    labs(x = 'Expected Goal (xG)', y = 'Expected Goal Against (xGA)')\n  \n})\n```\n:::\n\n\n\n### ShowModal of selected row\n\nWe set a reactive that activates when a `_cells_selected` and stores the name of the team in the selected row. With the reactive `team_selected` we filter the dataframe and build the ggplot. Finally, we set the `observeEvent` that triggers the modal based on the dataTable`_cells_selected`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nteam_selected <- reactive({\n  selected_team <- epl_standings %>% \n    slice(input$standings_cells_selected[1,1]) %>% \n    pull(team_name)\n})\n\n# Modal to display cumulative xG\nobserveEvent(\n  input$standings_cells_selected,\n  {\n    if(nrow(input$standings_cells_selected)>0){\n      showModal(\n        modalDialog(\n          title = paste0(team_selected(), \" Cumulative xG\"),\n          easyClose = T,\n          size = 'l',\n          plotOutput('rolling_xG')\n        )\n      ) \n    }\n  }\n)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}